




## ソート（応用編：多重キー／安定性）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：ペアソート / ソートメニュー応用編 **Step 5**
        
    - 代替：タプルソート / ソートメニュー応用編 **Step 6**
        
    - 代替：文字列のソート / ソートメニュー応用編 **Step 8**
        
- **気を付けること**: `sorted(key=..., reverse=...)` とタプルキー、安定性前提のキー順。
    
- **大切なこと**: 「主キー→従キー」の優先順位設計をコードで正しく表現。
    

## スタック・キュー（括弧整合＋基本）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：括弧列 / スタック・キューメニュー **Step 4**
        
    - 代替：逆ポーランド記法 / スタック・キューメニュー **Step 3**
        
    - 代替：エスカレーター / スタック・キューメニュー **Step 5**
        
- **気を付けること**: `list`でスタック、`collections.deque`でキュー。空ポップ/不一致の例外。
    
- **大切なこと**: 典型操作（push/pop, popleft/append）を**ノールック**で書けること。
    

## ハッシュ（辞書：頻度/突き合わせ）

- **優先度**: 高
    
- **問題/STEP**:
    
    - 本命：文字列の出現率 / データセット選択メニュー **Step 3**
        
    - 代替：価格の算出 / データセット選択メニュー **Step 4**
        
    - 代替：英小文字の出現率 / データセット選択メニュー **Step 2**
        
- **気を付けること**: `dict`, `Counter`, 既定値（`get`, `defaultdict`）。
    
- **大切なこと**: **O(1)想定**のキー参照で大入力に耐える実装。
    

## 累積和（基礎：1次元/区間和）

- **優先度**: **非常に高**
    
- **問題/STEP**:
    
    - 本命：区間の和 4 / 累積和メニュー **FINAL**
        
    - 代替：区間の和 3 / 累積和メニュー **Step 3**
        
- **気を付けること**: `s[i+1]=s[i]+a[i]`、半開区間で `s[r+1]-s[l]`。オフバイエラー。
    
- **大切なこと**: **前計算でクエリ高速化**（多クエリ対応）。
    

## 累積和（応用：2次元/累積和＋二分探索）

- **優先度**: **非常に高**
    
- **問題/STEP**:
    
    - 本命：二次元累積和 7 / 二次元累積和メニュー **FINAL**
        
    - 代替：区間の数え上げ 4 / データ構造応用メニュー **FINAL 相当**
        
- **気を付けること**: 2Dは**4項の足し引き**、インデックスの+1ずらし。
    
- **大切なこと**: 尺取り/二分探索との**併用発想**を持つ。
    

## 素数（エラトステネス）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：エラトステネスの篩 / 素数メニュー **Step 4**
        
    - 代替：素数大好き paiza くん / 素数メニュー応用編 **Step 1**
        
- **気を付けること**: 篩配列初期化、偶数スキップ、上限√N。
    
- **大切なこと**: まとまった回数の判定は**篩が圧倒的**に効く。
    

## 最大公約数（ユークリッド/複数GCD）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：最大公約数 / 素数メニュー **FINAL**
        
    - 代替：最も大きな最大公約数 / 森コン過去問セット7 **問2**
        
- **気を付けること**: `math.gcd` と `reduce`、0混入、負数。
    
- **大切なこと**: GCDは**下支えライブラリ**として素早く使う。
    

## 関数定義の復習（再帰の基礎）

- **優先度**: 任意（短時間で確認）
    
- **問題/STEP**:
    
    - 本命：フィボナッチ数（再帰） / アルゴリズム入門編 **チャプター6**
        
    - 代替：階乗関数の実装 / アルゴリズム入門編 **チャプター5**
        
- **気を付けること**: 終了条件、スタック深さ、戻り値。
    
- **大切なこと**: **小さな関数で分割**→テスト可能な形に。
    

## BFS 基礎（グリッド最短距離）

- **優先度**: **非常に高**
    
- **問題/STEP**:
    
    - 本命：迷路 / 幅優先・深さ優先探索メニュー **Step 1**
        
    - 代替：2頂点間の最短経路 / 幅優先・深さ優先探索メニュー **Step 2**
        
- **気を付けること**: `deque`、`visited`/`dist`の初期化、境界/壁判定。
    
- **大切なこと**: **レベル順**＝無重み**最短手数**の直観を固める。
    

## DFS 基礎（連結成分サイズ）

- **優先度**: **非常に高**
    
- **問題/STEP**:
    
    - 本命：島探し / スキルチェック過去問題セット **（島数え）**
        
    - 代替：連結の判定 / 新・BランクLvUp **Step 2**
        
- **気を付けること**: 再帰上限、4近傍/8近傍、訪問マーキング。
    
- **大切なこと**: **連結成分＝一筆書きで塗る**発想。
    

## BFS/DFS 応用（条件付き最短路／木集計）

- **優先度**: 高
    
- **問題/STEP**:
    
    - 本命：出口のない迷路 / グリッド版ダイクストラ問題セット **Step 2（BFS系）**
        
    - 代替：グループ企業1 / DAG・メモ化再帰メニュー **Step 3**
        
- **気を付けること**: 条件追加（鍵/コスト/制約）でも**BFS原則は同じ**。木は**部分木集計**の帰りがけ。
    
- **大切なこと**: 基本テンプレを**拡張**して解く練習。
    

## 二分探索（CT対策 Step5 指定）

- **優先度**: 高
    
- **問題/STEP**:
    
    - 本命：数字の検索 / 二分探索メニュー **Step 1**
        
    - 代替：範囲内の個数 / 二分探索メニュー **Step 7**
        
- **気を付けること**: 目的は**境界（下限/上限）**を取ること。無限ループ防止。
    
- **大切なこと**: `bisect_left/right`を**用途で言語化**（「A以上の最初」「B以下の最後」）。
    

## DP 入門（メモ化再帰 or DAG最長経路）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：フィボナッチ数列（メモ化） / DAG・メモ化再帰メニュー **Step 1**
        
    - 代替：仕事の順序（DAG最長経路） / 同 **Step 2**
        
- **気を付けること**: **部分問題の重複**とメモ表設計。
    
- **大切なこと**: トポロジー/メモ化で**指数→線形**に落とす感覚。
    

## ダイクストラ（heapq・重み付き最短路）

- **優先度**: 中
    
- **問題/STEP**:
    
    - 本命：コスト付き迷路の最短距離 / グリッド版ダイクストラ問題セット **Step 5**
        
    - 代替：最短経路のコスト / グラフメニュー応用編 **FINAL**
        
- **気を付けること**: `heapq`、距離確定と緩和、負辺不可。
    
- **大切なこと**: テンプレ（優先度付きキュー＋隣接リスト）を**型として保持**。
    

## 模擬練習（ジャンル違いで2題）

- **優先度**: 高（直前仕上げ）
    
- **問題/セット**:
    
    - 本命（文字列/配列系）：神経衰弱 / スキルチェック過去問題セット
        
    - 代替（盤面解析）：五目並べ / 同
        
    - 代替（集合・文字列）：アルファベット探し / BランクLvUp **FINAL**
        
- **気を付けること**: **35–40分/題**で実施→すぐ復習（境界条件・計算量）。
    
- **大切なこと**: **本番手順**（読解→方針→実装→検証）を固定。
    

---

### 共通テク・注意（超要約）

- 入力：`sys.stdin.read().split()`テンプレ。
    
- 文字列/配列：スライス、`join`, `count`, `set`, `Counter`。
    
- 計算量：N, Qの桁で**前計算 or 二分探索**を即選べること。
    
- デバッグ：小ケース自作、境界（空/端/同値/最大）を固定チェック。
    

---

**最終確認日**: 2025-10-16 JST



# 学習フェーズ構成（paiza／Python）

> 方針：**演習中心**。各メニューは「基礎→中位→総合（最終問題近辺）」の順で**厳選**して解く。  
> 原則として各メニューで **基礎2〜3問 → 中盤2問 → 最終1問** を目安に取捨選択。  
> 不得意分野は基礎を厚め、得意は最終問題から逆戻りで最小限。

---

## Phase 1：基礎の徹底（今〜1週間）

目的：Bランク下位〜中位問題を安定して通すための“実戦の土台”を完成させる。

### 対象（Bランク獲得ストーリー）

|トピック|目的|着手順|解く範囲（目安）|到達ゴール|
|---|---|---|---|---|
|配列活用（Step 2）|入出力・配列更新を安定化|すでに終了（復習は任意）|必要なら再演習 2問|ループ・条件・スライス・整形出力が迷いなく書ける|
|ソート（Step 3〜7）|組込ソートの運用（多重キー・安定性）|今すぐ|応用メニューから 3〜5問（2次元・多重キー中心）|`sorted(list, key=lambda x: (...))`を即時設計・実装|
|スタック・キュー（Step 8）|シミュレーション／探索の前段|ソートの直後|基礎 1〜2問（括弧整合、キュー処理）＋中盤 1問|`list`/`deque`の運用と典型の癖を掴む|
|累積和（Step 10）|区間和の高速化の型|スタックの次|基礎 2問（1次元）→ 中盤 2問（差分/区間加算）→ 最終 1問|`S[r]-S[l]`、差分配列、0/1化カウントを状況で選べる|
|素数・互除法（Step 13〜14）|典型の数論基礎|累積和の後|各 1〜2問（判定・篩／gcd連鎖）|√N 判定、エラトステネス、`math.gcd`の即応|

**具体的な進め方（例・4セッション）**

- セッション1（120分）：ソート応用 3問（多重キー、降順混在、安定性を意識）
    
- セッション2（90分＋30分復習）：スタック基礎1問→キュー1問→中位1問
    
- セッション3（120分）：累積和 基礎2問→区間加算（差分）1問
    
- セッション4（90分）：累積和 中位1問→最終近辺1問、数論（素数 or gcd）1問
    

---

## Phase 2：中級アルゴリズムの習得（来週〜）

目的：試験頻出の“方針構築”を鍛える（二分探索／BFS・DFSを軸）。

### 対象（コーディング試験対策ストーリー）

|トピック|目的|着手順|解く範囲（目安）|到達ゴール|
|---|---|---|---|---|
|二分探索（Step 5／応用 Step 9, 14）|最小十分値・位置・個数|最優先|基礎 2問（手書き）→ bisect 2問 → 応用 1問|「判定関数×境界法」「bisect系（left/right）」使い分け|
|BFS/DFS（Step 13）|迷路・到達・最短手数|最優先（並行）|BFS 基礎2問（最短路/到達）→ DFS 1問（連結成分）→ 応用 1〜2問|グリッド境界・visited管理・条件付き遷移が安定|
|ユークリッド互除法応用（Step 8）|多数のgcd/最小公倍数|二分探索の後|1〜2問|まとめ計算（配列全体のgcd/lcm）を安定実装|
|素数・ハッシュ応用（Step 15〜16）|出現数・集合判定|BFS/DFSの後|2問（辞書/集合での高速化）|`dict/Counter/set`でO(N)設計ができる|
|木・リスト系（Step 6, 11）|木の入出力・基本探索|余裕があれば|各1問|木の入力→隣接表→DFS/BFSの導線を確認|

**具体的な進め方（例・5セッション）**

- セッション1（120分）：二分探索 基礎2問（手書き境界法）→ bisect 1問
    
- セッション2（120分）：BFS 基礎2問（最短路、到達可否）
    
- セッション3（90分）：DFS 1問 → BFS 応用1問（条件付き）
    
- セッション4（90分）：二分探索 応用1問 → ハッシュ応用1問
    
- セッション5（60分）：gcd/lcm 1〜2問 → 木の入出力1問（任意）
    

---

## Phase 3：試験想定・実戦訓練（今月後半）

目的：B上位〜A下位入口を安定させ、本番の手順・配点を意識した時間内AC力をつける。

### 対象（Bランク後半＋対策後半）

|トピック|目的|解く範囲（目安）|到達ゴール|
|---|---|---|---|
|BFS/DFS（Bランク Step 16）|実戦想定の探索|最終近辺 2問（制約多め）|実装テンプレ＋方針の言語化→バグ出し短縮|
|新・Bランクレベルアップ（Step 17）|試験形式に近い総合問題|2問|読解→方針→実装の一連を40分内に収める|
|グラフ・DFS（対策 Step 18）|経路・到達・成分|1〜2問|隣接表構築→探索の手早さを強化|
|ダイクストラ／ワーシャルフロイド（Step 19〜20）|最短経路／全点対全点|各1問（任意）|`heapq`で単一始点。全対全は概要把握で十分|

**模擬回（2回を推奨）**

- 模擬1：Bランク過去問×2本（各40分＋復習20分）
    
- 模擬2：分野を変えて×2本（同配分）  
    復習は必ず**再提出レベル**まで修正して終了。
    

---

# 実践ロードマップ（日次の指針）

- **Week 1：ソート応用・スタック/キュー・累積和・数論**
    
    - ソート応用 3〜5問（多重キー／2次元）
        
    - スタック/キュー 2〜3問（括弧整合・キュー処理）
        
    - 累積和 4〜5問（1次元→差分→最終近辺）
        
    - 素数/互除法 各1〜2問（√N・篩／gcd連鎖）
        
- **Week 2：二分探索・BFS/DFS・ハッシュ**
    
    - 二分探索 5問（手書き2・bisect2・応用1）
        
    - BFS 基礎→応用 3〜4問／DFS 1〜2問
        
    - ハッシュ応用 2問（集計・集合）
        
    - 余力：木入力1問
        
- **Week 3（今月後半）：実戦仕上げ**
    
    - BFS/DFS（B Step16）最終近辺 2問
        
    - 新・Bレベルアップ（Step17）2問
        
    - グラフDFS（対策 Step18）1〜2問
        
    - 任意：ダイクストラ1問
        
    - 模擬2回（各80〜120分）
        

---

# メニューごとの「どの問題を解くか」の選び方（具体）

> paizaの各メニューはタイトルと難易度が段階化されています。**全問は不要**。以下の要領で**番号の浅い順→深い順→最終**を抽出します（問題名が環境で微妙に異なるため、**「基礎／中位／最終」帯から該当を選ぶ**運用にしてください）。

- **ソート（応用）**
    
    - 基礎：一次元の昇降順切替
        
    - 中位：二次元（タプル）多重キー（例：第1キー昇順、第2キー降順）
        
    - 最終：条件付き抽出→ソート→後処理（ランク付け・グルーピング）
        
- **スタック・キュー**
    
    - 基礎：括弧整合（スタック）／到着順処理（キュー）
        
    - 中位：複合コマンド実行（push/pop/size/empty）
        
    - 最終：シミュレーション（手続きの忠実実装）
        
- **累積和**
    
    - 基礎：1次元の累積和→区間和回答
        
    - 中位：差分配列で区間加算→復元／頻度カウント
        
    - 最終：制約付き区間カウント（0/1化→累積）／2次元累積の矩形和
        
- **素数**
    
    - 基礎：√N 判定
        
    - 中位：篩での列挙＋複数クエリ
        
    - 最終：区間内素数数え上げ（必要なら）
        
- **互除法**
    
    - 基礎：2数gcd／lcm
        
    - 中位：配列全体のgcd/lcm
        
    - 最終：分数の和の約分・連鎖処理
        
- **二分探索**
    
    - 基礎：手書き境界法（最小十分値）×2
        
    - 中位：`bisect_left/right`で個数・範囲
        
    - 最終：答えに対して二分（可否判定関数）
        
- **BFS/DFS**
    
    - 基礎：BFS最短路（グリッド）／DFS連結成分
        
    - 中位：条件付き移動（壁・コスト0/1相当の工夫）
        
    - 最終：多始点／多条件／集計付き
        

---

# 到達基準チェックリスト（提出前のセルフ判定）

- ソート：二次元多重キーを**即**書ける（lambda設計を迷わない）
    
- 累積和：`S[r]-S[l]`／差分配列による区間加算を**5分で**起こせる
    
- 二分探索：**境界法のテンプレ**を空で書ける／`bisect`で個数が出せる
    
- BFS/DFS：グリッド境界・訪問管理・最短路距離配列の**テンプレ**を即時投入
    
- ハッシュ：集計・集合・二列突き合わせを**辞書/集合**でO(N)に落とせる
    
- 数論：√N判定・篩、`math.gcd`の組み合わせを即応
    

---

# テンプレ最小セット（Python／抜粋）

`# 二分探索（境界法：最小十分値） def ok(x): ... lo, hi = -1, LIMIT+1 while hi - lo > 1:     mid = (lo + hi) // 2     if ok(mid): hi = mid     else: lo = mid print(hi)`

`# 累積和（1D） S = [0]*(n+1) for i in range(n):     S[i+1] = S[i] + A[i] # 区間 [l, r) の和 res = S[r] - S[l]`

`# 差分配列（区間加算） D = [0]*(n+1) for l, r, x in queries:     D[l] += x; D[r] -= x A = [0]*n; cur = 0 for i in range(n):     cur += D[i]; A[i] = cur`

`# BFS（グリッド） from collections import deque INF = 10**18 dist = [[INF]*W for _ in range(H)] dq = deque() dist[sy][sx] = 0; dq.append((sy, sx)) while dq:     y, x = dq.pop()     for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):         ny, nx = y+dy, x+dx         if 0<=ny<H and 0<=nx<W and grid[ny][nx] != '#':             if dist[ny][nx] > dist[y][x] + 1:                 dist[ny][nx] = dist[y][x] + 1                 dq.append((ny, nx))`

---

## 運用メモ

- 各セッションの最初に**5分で方針を言語化**（入力→出力→必要データ構造→計算量）。
    
- 1問に長くハマりすぎない。**20分で方針が立たなければ一旦保留**→別の類題→戻る。
    
- 解いた後は**模範解答を1つだけ**比較し、**改善点をObsidianテンプレに1行で追記**。
    
- 週末に**模擬回**を必ず入れて、時間内ACの感覚を作る。