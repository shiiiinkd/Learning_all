

## 学んだこと
global変数の宣言
マージソート (昇順) は、`データ列を二分し、それぞれをマージソートした後それらを「マージ (統合) 」する`ことを繰り返すソートアルゴリズムです。マージソートは、問題を小さな問題に分割して解くことを繰り返すことによって元の問題の答えを得る手法である「分割統治法」に基づいたアルゴリズムです。

## 模範解答
```python
count = 0
INF = 1000000001


def merge(a, left, mid, right):
    global count #global宣言でローカル変数を関数内でも扱えるようにする
    l = a[left:mid] #for文で代入していくよりも簡潔
    r = a[mid:right]
    l.append(INF) #最後はappend
    r.append(INF)

    lindex = 0
    rindex = 0

    for i in range(left, right):
        if l[lindex] < r[rindex]:
            a[i] = l[lindex]
            lindex += 1
        else:
            a[i] = r[rindex]
            rindex += 1
            count += 1


def merge_sort(a, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        merge_sort(a, left, mid)
        merge_sort(a, mid, right)
        merge(a, left, mid, right)


n = int(input())
a = list(map(int, input().split()))

merge_sort(a, 0, n)

print(*a)
print(count)
```

## 擬似コード
// アルゴリズムが正しく実装されていることを確認するために導入するカウンタ変数、ソート処理には関係がないことに注意  
count <- 0  
  
/**  
    部分データ列 A[left] ~ A[mid-1], A[mid] ~ A[right-1] はそれぞれ整列済み  
    2つの部分データ列をマージし、A[left] ~ A[right-1] を整列済みにする  
*/  
merge(A : 配列, left : 整数, mid : 整数, right : 整数)  
    // 2つの部分データ列のサイズ  
    nl <- mid-left  
    nr <- right-mid  
  
    // 部分データ列をコピー  
    for i = 0 to nl-1  
        L[i] <- A[left+i]  
    for i = 0 to nr-1  
        R[i] <- A[mid+i]  
      
    // 番兵  
    L[nl] <- INF  
    R[nr] <- INF  
      
    // 2つの部分データ列をマージして A[left] ~ A[right-1] に書き込む  
    lindex <- 0  
    rindex <- 0  
  
    for i = left to right-1  
        if L[lindex] < R[rindex] then  
            A[i] <- L[lindex]  
            lindex++  
        else  
            A[i] <- R[rindex]  
            rindex++  
            count++  
  
/**  
    A[left] ~ A[right-1] をマージソートする  
    配列 A をマージソートするには merge_sort(A, 0, n) を呼び出す  
*/  
merge_sort(A : 配列, left : 整数, right : 整数)  
    if left+1 < right  
        mid = (left + right) / 2  
        merge_sort(A, left, mid)  
        merge_sort(A, mid, right)  
        merge(A, left, mid, right)

## 自分の解答
```python
# // アルゴリズムが正しく実装されていることを確認するために導入するカウンタ変数、ソート処理には関係がないことに注意
count = 0
INF = 1000000001
# /**
#     部分データ列 A[left] ~ A[mid-1], A[mid] ~ A[right-1] はそれぞれ整列済み
#     2つの部分データ列をマージし、A[left] ~ A[right-1] を整列済みにする
# */
def merge(A,left,mid,right):
    global count  
    
    # // 2つの部分データ列のサイズ
    nl = mid-left
    nr = right-mid
    
    L = [0]*(nl+1)
    R = [0]*(nr+1)
    # // 部分データ列をコピー
    for i in range(nl):
        L[i] = A[left+i]
    for i in range(nr):
        R[i] = A[mid+i]
    
    # // 番兵
    L[nl] = INF
    R[nr] = INF
    
    # // 2つの部分データ列をマージして A[left] ~ A[right-1] に書き込む
    lindex = 0
    rindex = 0

    for i in range(left,right):
        if L[lindex] < R[rindex]:
            A[i] = L[lindex]
            lindex += 1
        else:
            A[i] = R[rindex]
            rindex += 1
            count += 1
            
 
    
          

# /**
#     A[left] ~ A[right-1] をマージソートする
#     配列 A をマージソートするには merge_sort(A, 0, n) を呼び出す
# */
def merge_sort(A,left,right):
    if left+1 < right:
        mid = (left + right) // 2
        merge_sort(A, left, mid)
        merge_sort(A, mid, right)
        merge(A, left, mid, right)
   
        
n = int(input())
A = list(map(int,input().split()))

merge_sort(A,0,n)
print(*A)
print(count)
```

