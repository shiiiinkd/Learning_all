

## 学んだこと
シェルソートは、挿入ソートを改良したアルゴリズムです。挿入ソートが整列済みのデータ列に強いことを利用しています。  
  
シェルソートでは、`データ列において一定の間隔 h だけ離れた要素たちからなる部分列を対象とした挿入ソート`を、h を小さくしながら (間隔を狭めながら) 繰り返してソートを行っていきます。h は適当に大きな値から始め、段階的に小さくしていき、最終的に 1 にします。h が 1 のとき、間隔が 1 離れた要素たちからなる部分列というのは元のデータ列そのものですから、このとき単純な挿入ソートを行うことになります。この時点でデータ列は既にほとんど整列済みとなっていることが期待されるため、ここで挿入ソートの強みが活かされます。

## 模範解答
```python
def insertion_sort(a, n, h):
    num_of_move = 0

    for i in range(h, n): #h番目からiを増やしていく
        x = a[i]
        j = i - h #iからh戻ったところから挿入ソートの比較をしていく

        while j >= 0 and a[j] > x: #つまり「h離れた部分で比較し入れ替えが必要ならば」
            a[j + h] = a[j] 
            j -= h
            num_of_move += 1

        a[j + h] = x

    print(num_of_move)


def shell_sort(a, n, h):
    for h_i in h:
        insertion_sort(a, n, h_i)


n = int(input())
a = list(map(int, input().split()))
k = int(input())
h = list(map(int, input().split()))

shell_sort(a, n, h)
```

## 擬似コード

insertion_sort(A : 配列, n : Aの要素数, h : 間隔)  
    // アルゴリズムが正しく実装されていることを確認するために導入するカウンタ変数、ソート処理には関係がないことに注意  
    num_of_move <- 0  
  
    for i = h to n-1  
        // A[i] を、整列済みの A[i-ah], ..., A[i-2h], A[i-h] の適切な位置に挿入する  
  
        // 実装の都合上、A[i] の値が上書きされてしまうことがあるので、予め A[i] の値をコピーしておく   
        x <- A[i]  
  
        // A[i] の適切な挿入位置を表す変数 j を用意  
        j <- i-h  
  
        // A[i] の適切な挿入位置が見つかるまで、A[i] より大きい要素を後ろにずらしていく  
        while j >= 0 AND A[j] > x  
            A[j+h] = A[j]  
            j -= h  
            num_of_move++  
          
        // A[i] を挿入  
        A[j+h] <- x  
  
shell_sort(A : 配列, n : Aの要素数, H : 間隔列)  
    for h in H  
        insertion_sort(A, n, h)


## 自分の解答
```python
N = int(input())
A = list(map(int,input().split()))
K = int(input())
H = list(map(int,input().split()))


def insertion_sort(A,n,h):
    # // アルゴリズムが正しく実装されていることを確認するために導入するカウンタ変数、ソート処理には関係がないことに注意
    num_of_move = 0

    for i in range(h,n):
        # // A[i] を、整列済みの A[i-ah], ..., A[i-2h], A[i-h] の適切な位置に挿入する
        
        # // 実装の都合上、A[i] の値が上書きされてしまうことがあるので、予め A[i] の値をコピーしておく 
        x = A[i]

        # // A[i] の適切な挿入位置を表す変数 j を用意
        j = i-h

        # // A[i] の適切な挿入位置が見つかるまで、A[i] より大きい要素を後ろにずらしていく
        while j >= 0 and A[j] > x:
            A[j+h] = A[j]
            j -= h
            num_of_move+=1
            
        # // A[i] を挿入
        A[j+h] = x
    print(num_of_move)
    
    
def shell_sort(A,N,H):
    for h in H:
        insertion_sort(A,N,h)


shell_sort(A,N,H)
```

