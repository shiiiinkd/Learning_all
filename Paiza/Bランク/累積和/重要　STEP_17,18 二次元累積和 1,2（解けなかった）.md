

## 学んだこと
二次元配列における累積和の利用、リスト内包表記の重要性
「**リストの多重生成は必ず内包表記で書く**」というのが、実務でも教育でも**定番のベストプラクティス**
```python
for i in range(1,6):
    for j in range(1,6):
        s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + a[i-1][j-1]

#実際にｓに格納されるのは下のとおり
#[[  0,   0,   0,   0,   0,   0],
 #[  0,   1,   3,   6,  10,  15],
 #[  0,   3,   8,  15,  24,  35],
 #[  0,   6,  15,  27,  42,  60],
 #[  0,  10,  24,  42,  64,  90],
 #[  0,  15,  35,  60,  90, 125]]

```

```python
a = [[0]*5]*5
for i in range(5):
    a[i] = list(map(int,input().split()))
# s = [[0]*6]*6
s = [[0] * 6 for _ in range(6)]

for i in range(1,6):
    for j in range(1,6):
        s[i][j] = s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i-1][j-1]


ans = s[4][4]-s[4][1]-s[1][4]+s[1][1]
print(ans)
```
- 上の回答について、コメントアウトされている書き方だとACにならない。なぜなら`s = [[0]*6]*6`だと0が6個並んだリストが6回複製されているだけだから。つまり、`s[i][j]` を1か所更新すると、同じ列 j が他の行でも同時に書き変わるということが起きてしまい、正しい値の更新が行われない。
- `a = [[0]*5]*5`が動いたのは`a[i] = list(map(int, input().split()))` で各行を丸ごと別リストに置き換えているため。
よってリストは基本的に内包表記で以下のように記述することにする

```python 
a = [[0]*5 for _ in range(5)]
s = [[0]*6 for _ in range(6)]
```


## 模範解答
```python
a = [[i+j for i in range(1,6)]for j in range(5)]
s = [[0] * 6 for _ in range(6)]

for i in range(1,6):
    for j in range(1,6):
        s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + a[i-1][j-1]

print(s[4][4] - s[1][4] - s[4][1] + s[1][1])
```