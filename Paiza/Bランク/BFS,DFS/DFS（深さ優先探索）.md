

## 学んだこと
DFSの概念と実装
DFS、BFSの違い

![[Pasted image 20251108130327.png]]
DFS→深さ優先探索。最初の頂点から一番深いところまで行ってから順に戻って再帰的に探索する（スタック）
応用例：連結成分、到達可能性、サイクル検出、トポロジカルソート（post順）、部分木集計、タイムスタンプ

BFS→幅優先探索。最初の頂点から行ける頂点をすべて探索してから順に階層的に探索する（キュー）
応用例：最短路（非負重み・無重み）、レベル計算、到達可能性

#### 特徴
- 計算量はどちらも`O(V + E)
- DFS：最短距離は保証しない。行きがけ（到達時にprint）と帰りがけ（探索完了順にprint）がある
- BFS：重みが同一の場合、最短距離を保証する（重みがある場合はダイクストラ法が必要）

## 深さ優先探索の実装
```python
# 再帰の深さ対策（必要に応じて調整、今回は行きがけで実装）
import sys
sys.setrecursionlimit(1_000_000)

# 深さ優先探索（再帰）
def dfs(G, v, seen): # グラフの隣接リスト,探索中の頂点,訪問済みリスト
    seen[v] = True  # v を訪問済みにする
    print(v) # 訪問した頂点を順に出力,
    for next_v in G[v]:  # v から行ける隣接頂点をすべて見る
        if seen[next_v]:
            continue      # 既に訪問済みならスキップ
        dfs(G, next_v, seen) # 未訪問なら再帰的に探索
        # 帰りがけの場合はここにprint(v)の処理を書く

def main():
    import sys
    input = sys.stdin.readline

    # 頂点数 N, 辺数 M
    N, M = map(int, input().split())

    # 無向グラフ（隣接リスト）
    G = [[] for _ in range(N)]
    for _ in range(M):
        a, b = map(int, input().split())
        # 入力が 0-index 前提（Qiita記事と同様）
        # もし 1-index なら: a -= 1; b -= 1 にしてから append してください
        G[a].append(b)
        G[b].append(a)

    # 頂点 0 から探索開始
    seen = [False] * N
    dfs(G, 0, seen)

if __name__ == "__main__":
    main()

```

## コードの意味

#### 1) 目的
- **頂点0から到達できる頂点をDFSでたどり、訪問順に出力する。**

#### 2) データ構造
- `G：` **隣接リスト**（`G[v]` に「v から行ける頂点」の配列）
- `seen：` **訪問済み管理**（`True` ならその頂点は訪問済み）

#### 3) 入力の処理
1. `N, M` を読む（頂点数・辺数）
2. `G = [[] for _ in range(N)]` で隣接リストを作る
3. 各辺 `a, b` を読み、**無向**なので `G[a].append(b); G[b].append(a)`  
    （※入力が1始まりなら `a -= 1; b -= 1` してから追加）
4. （任意）`for u in range(N): G[u].sort()` で訪問順を安定化

#### 4) DFS 関数の役割
- `dfs(G, v, seen)`
    1. `seen[v] = True` … **v を訪問済みにする**    
    2. **行きがけ処理**（今回は `print(v)` で「訪問順」を出力） 
    3. `for next_v in G[v]:` で **隣接頂点を順に確認**
        - 既に `seen[next_v]` ならスキップ    
        - 未訪問なら `dfs(G, next_v, seen)` を再帰呼び出し    
    4. （必要なら）**帰りがけ処理**をここに書く  
        例：部分木集計、ポストオーダの記録など

#### 5) 実行の起点
- `seen = [False] * N` で全頂点を未訪問に初期化
- `dfs(G, 0, seen)` を呼び出す（頂点0を起点）
- （連結でないグラフが複数ある場合）
    `for s in range(N):     if not seen[s]:         dfs(G, s, seen)`
    つまり連結でない複数のグラフについてそれぞれに深さ優先探索を実行できる

#### 6) 出力仕様
- 今回は **行きがけで `print(v)`** しているため、  
    **「DFSの訪問順」** がターミナルに 1 行ずつ出ます。
- 最終的な到達可否を見たい場合は、`main()` の最後で `print(seen)` などに切り替える。

#### 7) 計算量
- 時間：`O(V + E)`（各頂点・各辺を高々1回ずつたどる）
- 空間：`O(V)`（`seen` と再帰スタック）
  
  
注意：Paizaの進め方に注意
- **迷路** … **BFS**（無重み最短路）
    
- **2頂点間の最短経路** … **BFS**（木／グラフの最短手数）
    
- **2頂点間の距離** … **BFS**（距離レベル）
    
- **領域の個数** … **DFS**（グリッドの塗りつぶし＝連結領域数）
    
- **1頂点の移動** … **DFS**（木の走査・行き/帰りがけの素振り）
    
- **連結成分の個数** … **DFS**（グラフの連結成分カウント）