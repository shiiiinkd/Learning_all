

## 基本概念
- **「単調性（増加 or 減少）」をもつ範囲から、条件を満たす境界や値を効率的に探す」（ソート前提）
- 昇順配列内の値の位置、条件を満たす最小値・最大値（最小コスト、最短時間、最小速度など）


## 二種類の探索方法
### 1. 一致探索
#####   目的：A`[mid] == k となる要素（特定の値）を探す
#####   使用例：配列にkが存在するか判定する
```python
def binary_search(A, k):
    left, right = 0, len(A) - 1
    while left <= right:
        mid = (left + right) // 2
        if A[mid] == k:
            return mid
        elif A[mid] < k:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # 見つからない

```
#####   特徴：一致を探すだけ

### 2. 境界探索(一致探索の一般化)
#####   目的： 「条件」を満たす最小(もしくは最大)の位置 を探す
######     条件１：ｘ以上が始まる位置を探索
```python
def lower_bound(A, x):
    left, right = 0, len(A)
    while left < right:
        mid = (left + right) // 2
        if A[mid] >= x: # 条件：A[i] ≥ x
            right = mid
        else:
            left = mid + 1
    return left
```

######     条件２：ｘを超える位置を探索
```python
def upper_bound(A, x):
    left, right = 0, len(A)
    while left < right:
        mid = (left + right) // 2
        if A[mid] > x: # 条件：A[i] > x
            right = mid
        else:
            left = mid + 1
    return left
```
#####   特徴：見つからない場合でも常に正しい位置を返す
　　　　while left < right + [left,right) が定石（右開区間）

### 二分探索実装での大切なルール
- 探索区間：`[left, right)（右開区間）
- ループ条件：`while left < right`
- return値：`left(right) （どちらでも同じ値になる）
- 判定条件：`lower：>= , upper：>
- ソート前提：`a.sort()を初めに実行

### 重要：具体的な使い方

| 求めたいもの     | 正しい式                 | 意味         |
| :--------- | :------------------- | :--------- |
| x以上の開始位置   | `lower_bound(x)`     | xを含む最初の位置  |
| xより大きい開始位置 | `upper_bound(x)`     | xを超えた最初の位置 |
| x以下の終端     | `upper_bound(x) - 1` | 最後のxの位置    |
| x未満の終端     | `lower_bound(x) - 1` | 最後のx未満の位置  |
 `終端は同じ値が複数あった時に、どの位置を返すかが異なるため使い方に注意が必要

### 重要：標準ライブラリからのimport
```python
from bisect import bisect_left, bisect_right

a.sort()
i = bisect_left(a,x) # lower_bound(a,x)
j = bisect_right(a,x) # upper_bound(a,x)
```