

## 学んだこと
スタックの実装、スタックを使わない括弧列問題の解き方（非推奨）

前提：スタック→回転ずしの皿
　　　　　　　push → append 上に積む
　　　　　　　pop → pop() 上からとる
　　　　　　　stack [-1] → topを指す(最初に削除操作される要素)
　　　キュー　→レジの順番待ち
　　　　　　　enqueue → append 末尾に追加
　　　　　　　dequeue → pop(0)（ただし非効率のためdequeを使う）、先頭から削除

## 問題内容
N 文字の 括弧列 S が与えられます。与えられた 括弧列 が 正しい括弧列 かどうか判定してください。

ここで、 括弧列 とは以下のように定義します。

* ( または ) または空文字のみで構成される文字列

また、 正しい括弧列 とは以下のように定義します。

1. 空文字列は正しい括弧列である。
2. 文字列 s が正しい括弧列であるとき、 ( + s + ) は正しい括弧列である。
3. 文字列 s , t が正しい括弧列であるとき、 s + t は正しい括弧列である。

たとえば、以下の文字列はすべて 正しい 括弧列です。


()
(())
()()
(()())
((((())())()))


また、以下の文字列はすべて 正しくない 括弧列です。

)(
(
())
((())
(()()))((()())()

## 方針
- 正しい括弧か？ <=> （）の順番に連続する括弧列を削除する操作を最後まで行い、すべての過去列を削除できるか？に言い換え
  →スタックの問題ととらえる
- stackのトップが（ かつ読み込んだ要素が ）ならstackから削除する（len(stack) > 0)
- 削除条件に当てはまらない→スタックに要素を追加

## 模範解答（推奨）
```python
#スタックを利用
n = int(input())
s = input()

st = []

for i in range(n):
    if len(st) > 0 and st[-1] == "(" and s[i] == ")":
    # st[-1]はスタック（リスト）の末尾要素、つまりスタックのtop(最初に削除する要素)
    # len(st) > 0がないと、空のときにst[-1]がエラーになるため必要
        st.pop() #pop(削除)
    else:
        st.append(s[i])  #push(追加)
if len(st) == 0:
    print("Yes")
else:
    print("No")
```

## 自分の解答（非推奨）
```python
#スタックを使用しない方法でAC、非推奨
n = int(input())
s = input()
check = 0 #breakの確認
count = 0 #未処理の「(」の個数
for x in s:
    if count < 0:
        print("No")
        check += 1
        break
    
    elif x == "(":
        count += 1
    elif x ==")":
        count -= 1

if count == 0 and s[n-1] == ")":
    print("Yes")
elif check !=1:
    print("No")
```



