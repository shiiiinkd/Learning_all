- if文は必ずしもif,elif,elif,...とする必要はない。複数の条件をすべて確認したいときはif,if,if,if,...としてもOK
 ```python
 #B081:花壇のロープ
h,w = map(int,input().split()) #hは行、wは列
s = [input() for _ in range(h)]
count = 0
#隣接する＃の数をｎとするとcount = 4-nになる
#隣接する＃の数を判定するプログラムをかけばいい
#s[i][j]を中心として、s[i-1][j],s[i+1][j],s[i][j-1],s[i][j+1]を調べて、＃の数だけcount[i][j]を減らす

for i in range(h):
    for j in range(w):
        if s[i][j] == "#":
            count += 4
            #これより下はすべて確認してほしい。elifだと条件抜けしてしまう。
            if i != 0 and s[i-1][j] == "#":
                count -= 1
    
            if i != h-1 and s[i+1][j] == "#":
                count -= 1
                
            if j != 0 and s[i][j-1] == "#":
                count -=1
                
            if j != w-1 and s[i][j+1] == "#":
                count -= 1
                

print(count)    
 ```

n,x = map(int,input().split())
a = list(map(int,input().split()))
count = 0
a.sort()

if sum(a)-max(a)+x <= max(a):
    print(-1)
else:
   
    for i in range(n):
        for j in range(n-i):
            if j == n-i:
                
                x += a[0]
                count += 1
                print(count)
            if x == a[j] == max(a):
                x += a[j]
                count += 1
                a.pop(j)
                if x > max(a):
                    print(count)
                    break
                break
            if x < a[j]:
                x += a[j-1]
                count += 1
               
                a.pop(j-1)
                if x > max(a):
                    print(count)
                    break
                break
        
        
    
#ソートした配列について、なるべく自分の大きさにより近いスライムを食べ続ければよい。
#a[i]について、x < a[i]となるとき、x += a[i-1]として、del(a[i-1])として、回数をカウントする


        